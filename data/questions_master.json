[
  {
    "id": "two-sum-001",
    "title": "Two Sum",
    "metadata": {
      "difficulty": "Easy",
      "topics": ["Array", "Hash Table"],
      "companies": ["Google", "Amazon", "Meta"],
      "frequency_rating": 5
    },
    "search_text": "Given an array of integers and a target value, return the indices of two numbers that add up to the target.",
    "judge_context": {
      "optimal_solution_code": "class Solution {\n  twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n      const complement = target - nums[i];\n      if (map.has(complement)) {\n        return [map.get(complement), i];\n      }\n      map.set(nums[i], i);\n    }\n    return [];\n  }\n}",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "edge_cases": [
        "Negative numbers",
        "Duplicate values",
        "No solution exists"
      ],
      "key_insights": [
        "Use hash map to store complements",
        "Single pass solution possible",
        "Trade space for time"
      ]
    },
    "display_markdown": "### Two Sum\n\nGiven an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\n**Example:**\n```\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: nums[0] + nums[1] == 9\n```\n\n**Constraints:**\n- 2 <= nums.length <= 10^4\n- -10^9 <= nums[i] <= 10^9\n- Only one valid answer exists"
  },
  {
    "id": "valid-parentheses-002",
    "title": "Valid Parentheses",
    "metadata": {
      "difficulty": "Easy",
      "topics": ["Stack", "String"],
      "companies": ["Google", "Microsoft", "Amazon"],
      "frequency_rating": 4
    },
    "search_text": "Given a string containing brackets, determine if the input string has valid matching pairs and correct order of opening and closing brackets.",
    "judge_context": {
      "optimal_solution_code": "class Solution {\n  isValid(s) {\n    const stack = [];\n    const pairs = { '(': ')', '{': '}', '[': ']' };\n    \n    for (const char of s) {\n      if (pairs[char]) {\n        stack.push(char);\n      } else {\n        const top = stack.pop();\n        if (pairs[top] !== char) return false;\n      }\n    }\n    return stack.length === 0;\n  }\n}",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "edge_cases": [
        "Empty string",
        "Only opening brackets",
        "Only closing brackets",
        "Mismatched types"
      ],
      "key_insights": [
        "Stack data structure is natural fit",
        "Match closing bracket with most recent opening",
        "Check stack is empty at end"
      ]
    },
    "display_markdown": "### Valid Parentheses\n\nGiven a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\n**Example:**\n```\nInput: s = \"()[]{}\"\nOutput: true\n\nInput: s = \"(]\"\nOutput: false\n```\n\n**Constraints:**\n- 1 <= s.length <= 10^4\n- s consists of parentheses only"
  },
  {
    "id": "course-schedule-003",
    "title": "Course Schedule",
    "metadata": {
      "difficulty": "Medium",
      "topics": ["Graph", "DFS", "Topological Sort"],
      "companies": ["Google", "Meta"],
      "frequency_rating": 4
    },
    "search_text": "Given course prerequisites as pairs, determine if it is possible to finish all courses without circular dependencies using graph cycle detection.",
    "judge_context": {
      "optimal_solution_code": "class Solution {\n  canFinish(numCourses, prerequisites) {\n    const graph = Array.from({ length: numCourses }, () => []);\n    const visited = new Array(numCourses).fill(0);\n    \n    for (const [course, prereq] of prerequisites) {\n      graph[prereq].push(course);\n    }\n    \n    const hasCycle = (node) => {\n      if (visited[node] === 1) return true;\n      if (visited[node] === 2) return false;\n      \n      visited[node] = 1;\n      for (const neighbor of graph[node]) {\n        if (hasCycle(neighbor)) return true;\n      }\n      visited[node] = 2;\n      return false;\n    };\n    \n    for (let i = 0; i < numCourses; i++) {\n      if (hasCycle(i)) return false;\n    }\n    return true;\n  }\n}",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V + E)",
      "edge_cases": [
        "No prerequisites",
        "Self-loop",
        "Disconnected components"
      ],
      "key_insights": [
        "Model as directed graph",
        "Detect cycles using DFS with three states",
        "0=unvisited, 1=visiting, 2=visited"
      ]
    },
    "display_markdown": "### Course Schedule\n\nThere are `numCourses` courses labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before course `ai`.\n\n**Example:**\n```\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: Take course 0, then course 1\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: Circular dependency\n```\n\n**Constraints:**\n- 1 <= numCourses <= 2000\n- 0 <= prerequisites.length <= 5000"
  }
]